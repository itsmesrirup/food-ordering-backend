spring.application.name=food-ordering-backend

# --- Database Configuration ---
# This configuration is now much cleaner and more standard.
# For local development:
# On Render, the SPRING_... environment variables will override these.
# Locally, the fallback values will be used.
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/restaurantdb}
spring.datasource.username=saanvikadas
spring.datasource.password=Welcome123

# For production on Render (these properties will be overridden by environment variables):
# We will set spring_datasource_url, spring_datasource_username, and spring_datasource_password in Render.

spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# --- Security Configuration ---
# Use the production secret on Render, or the local fallback key.
application.security.jwt.secret-key=${JWT_SECRET_KEY:d0FSkofwnaHcpwVF2TFoOdOT3DvcCHgHM4zyfBjmjI0=}

# --- Hikari Connection Pool Configuration ---
# Set the maximum number of connections in the pool.
# 3 is a safe number for a free/starter tier database.
spring.datasource.hikari.maximum-pool-size=3

# Set the minimum number of idle connections to keep open.
spring.datasource.hikari.minimum-idle=1

# Set the maximum time a connection can be idle before being retired.
spring.datasource.hikari.idle-timeout=30000

# Set the maximum time to wait for a connection from the pool.
spring.datasource.hikari.connection-timeout=20000

# --- Email Configuration ---
# Use Render ENV variables if they exist, otherwise use dummy/local values.
sendgrid.api.key=${SENDGRID_API_KEY:dummy-key-for-local}
sender.email.address=${SENDER_EMAIL:itsmesrirup@gmail.com}